After installation, all the following files should have been automatically generated.


## /services/Context.ts

This file exports the type of the `Context` object that will be passed at each request.

In particular, the `Context` object is used to tell who sent a request to the server and to perform authorization.

After installation, this file content should be:

```typescript
export type Context = undefined
```

A typical use case is to have a context like this:

```typescript
import { User } from "@prisma/client"

export type Context = {
  user?: User // the user that sent a request
}
```

## /services/Service.ts

This file exports your `Service` class that all your services should extend.

```typescript
import { BaseService } from "@digitak/gravity"
import { Context } from "./Context"

export class Service extends BaseService<Context> {
  // you can add here properties and methods common to all your services
}
```

## /services/math/index.ts

This is a sample service that you can delete or do whatever you want with.

```typescript
import { Service } from "../Service"

export class math extends Service {
  add(x: number, y: number): number {
    return x + y
  }

  subtract(x: number, y: number): number {
    return x - y
  }
}
```

Here our service exposes two functions: `add` and `subtract`.

Later on, the client will be able to call them by using the `api` object proxy, like this:

```typescript
import { api } from "/api"

const result = await api.add(1, 2) // should be 3
const otherResult = await api.subtract(2, 1) // should be 1
```

> Most of the time, api calls will be done at component-level with the `useApi()` composable

## /services/index.ts

This file is the `index of your services`. It means every service that you want to expose to your client must be exported here in the `services` object.

After installation, this file content should be:

```typescript
import { math } from "./math" // sample service

export const services = {
  math, // we expose our "math" service to our client 
}
```

When creating more services, this file will grow:

```typescript
import { math } from "./math"
import { otherService1 } from "./otherService1"
import { otherService2 } from "./otherService2"

export const services = {
  math,
  otherService1,
  otherService2,
}
```

> The `services` variable will be passed to the server entry point. When receiving a request, the server will then call the right function of the right service and send the response.

> The `services` variable will also be passed to the client `api` object but **only as a type**. Thanks to this trick, the `api` object will be well-typed.


## /schema.json

This file is automatically generated from the `services` object defined in `/services/index.ts`.

It uses [Typezer](https://www.npmjs.com/package/typezer) to extract the Typescript types.

> The `schema.json` content will be passed be passed to the server entry point. When receiving a request, the server will check the expected parameters type and validate them.

You can use this file to generate your api documentation.

As a generated file, `/schema.json` should be added to the `.gitignore` list. It makes no sense to share it as it is directly dependent on your source code. If everything went well, the gravity cli did it during the installation.

> During development, a smart watcher will regenerate this file when needed.

## /api.ts

This file is your client's entry point to call a server function. It is the **bridge** between your server and your client.

> If you opted for a **server-only architecture**, you are not concerned by this file.

```typescript
import type { services } from "./services"

// uncomment the right line:
import { defineApi } from "@digitak/gravity-svelte"
// import { defineApi } from "@digitak/gravity-solid"
// import { defineApi } from "@digitak/gravity-react"
// import { defineApi } from "@digitak/gravity-vue"

export const { api, useApi } = defineApi<services>({
  // additional options go there
})
```


## Server entry file

The main file of your server depends if you are using a **full-stack architecture** or not. If so, you will have to use your framework-specific request handler.

### /main.ts (Gravity)

This is the entry point of your server for the **server + client** and **server-only** architectures.

The role of this file is to create a node server and pass as argument the gravity handler.

```typescript
import { createServer } from "http";
import { gravity } from "@digitak/gravity/node";

import type { Context } from './services/Context';
import { services } from "./services";
import schema from "./schema.json";

const PORT = 3000;

const handler = gravity<Context>({
  services,
  schema,
  // additional options go there
}),

const server = createServer(handler);

server.listen(PORT, () => {
  console.log(`Gravity server listening to port ${PORT} âœ¨`);
});
```

As you can see, it is very low-level and allows you to customize your node server as you wish.

### /src/hooks.ts (SvelteKit)

When using Gravity as **full-stack architecture** with **SvelteKit**, your request handler is in `/src/hooks.ts`.

```typescript
import { gravity } from '@digitak/gravity-svelte';

import type { Context } from './services/Context';
import { services } from './services';
import schema from './schema.json';

export const handle = gravity<Context>({
  services,
  schema,
  // additional options go there
});
```

### /src/api/index.ts (Next)

ðŸš§ Work in progress

### /middleware.ts (Nuxt)

ðŸš§ Work in progress
