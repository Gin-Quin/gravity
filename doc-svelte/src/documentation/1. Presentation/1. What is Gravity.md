**Gravity** is a **modern RPC framework** written in Typescript. RPC stands for [remote procedure call](https://en.wikipedia.org/wiki/Remote_procedure_call) and it means we will be able to call from the client functions **defined in the server** like if it's just a normal Javascript function.

That means no more untyped and dangerous Rest or GraphQL apis. Just regular, normal, well-typed functions.

Does it sound cool?

Gravity:

- proposes a clean and scalable architecture based on **services**,
- can integrate with a many different frameworks and architectures,
- handles authorization and data access via a declarative approach,
- can be easily used to create a safe bridge between your ORM (like Prisma) and your front-end. You can stop writing CRUD function that mimic your ORM, just declare what your user can do or not do,
- shares Typescript types between server and client,
- automatically reads Typescript types to validate client parameters against their type definition.


## Why?

```typescript twoslash
type Toto = {
  x: number
}

const toto: Toto = {
  x: 12
}
```



Gravity is born because communicating between the server and the client was too complicated. The creator of the [Blitz framework](https://blitzjs.com/#) shared very well his frustration at the [start of this video](https://youtu.be/TTe56M1QscM) about this.

The problem is: how to have a **simple** and **safe** client <-> server communication?

Along Blitz, some other solutions came to life to try to resolve this issue. We are talking about [tRPC](https://trpc.io/), which is simple RPC framework based on zod, or [Remix](https://remix.run/), which is an alternative to Next that makes an heavy use on forms to communicate.

In comparison to theses frameworks, **Gravity** tries to stay as simple as possible.