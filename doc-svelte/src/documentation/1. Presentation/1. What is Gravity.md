**Gravity** is a **modern RPC framework** written in Typescript and for Typescript. RPC stands for [remote procedure call](https://en.wikipedia.org/wiki/Remote_procedure_call) and it means we will be able to call from the client functions **defined in the server** like if it's just a normal Javascript function.

That means no more untyped and dangerous Rest or GraphQL apis. No more typos when calling an URL, no more complicated GraphQL resolvers or custom scalars.

Just regular, normal functions.

Doesn't it sound cool?

Gravity:

- proposes a clean and scalable architecture based on **services**,
- can integrate with a many different frameworks and architectures,
- handles authorization and data access via a declarative approach,
- can be easily used to create a safe bridge between your ORM (like Prisma) and your front-end. You can stop writing CRUD function that mimic your ORM, just declare what your user can do or not do,
- shares Typescript types between server and client.


## Why?

Gravity is born because communicating between the server and the client was too complicated. The creator of the [Blitz framework](https://blitzjs.com/#) shared very well his frustration at the [start of this video](https://youtu.be/TTe56M1QscM) about this.

The problem is: how to have a **simple** and **safe** client <-> server communication?

Along Blitz, some other solutions came to life to try to resolve this issue. We are talking about [tRPC](https://trpc.io/), which is simple RPC framework based on zod, or [Remix](https://remix.run/), which is an alternative to Next that makes an heavy use on forms to communicate.

In comparison to theses frameworks, **Gravity** tries to stay as simple as possible.